{
  
    
        "post0": {
            "title": "(EN)Writing Efficient Python Code",
            "content": "These are notes from the Writing Efficient Python Code course by DataCamp. . This course covers the following topics: . How to write clean, fast, and efficient Python code | How to profile a code for bottlenecks | How to eliminate bottlenecks and bad design patterns | . . Foundations for efficiencies . In the context of this course, efficient Python code is: executing quickly for the task at hand | minimizing the memory footprint | following Python’s coding style principles (i.e., PEP) | . | . Building with built-ins . Python built-in components . Built-in components are referred as the Python Standard Library, and the library comes with every Python installation. | Some built-in components include: Built-in types (e.g., list, tuple, set, and others) | Built-in functions (e.g., print(), len(), range(), and others) | Built-in modules (e.g., os, sys, itertools, and others) | . | Built-ins have been optimized to work within the Python language itself, so using them is recommended, if one exists. | . Useful built-ins: range() . It returns a sequence of the given number between the given range. | syntax range(stop): create a sequence of numbers from 0 to a stop value (which is exclusive) | range(start, stop, step): create a sequence of numbers from a start value to a stop value (which is exclusive) with a step size. | . | exercises . # Create a list of people that arrived at a party we&#39;re hosting. names = [&#39;Jerry&#39;, &#39;Kramer&#39;, &#39;Elaine&#39;, &#39;George&#39;, &#39;Newman&#39;] # Create an empty list to store the indexed list. indexed_names = [] # Use a for loop to get the indexed list. for i in range(len(names)): index_name = (i, names[i]) indexed_names.append(index_name) . | . Useful built-ins: enumerate() . It returns an indexed list. | syntax enumerate(iterable, start = 0) | . | exercises . # Create an empty list to store the indexed list. indexed_names = [] # Rewrite the for loop to use enumerate for i, name in enumerate(names): index_name = (i, name) indexed_names.append(index_name) # Rewrite the above for loop using list comprehension indexed_names_comp = [(i, name) for i, name in enumerate(names)] # Unpack an enumerate object with a starting index of one indexed_names_unpack = [*enumerate(names, start = 1)] . | . Useful built-ins: map() . It returns a map object of the results after applying the given function to each item of a given iterable. | syntax map(function, iterable) | . | exercises . # Create a list of people that arrived at a party we&#39;re hosting. names = [&#39;Jerry&#39;, &#39;Kramer&#39;, &#39;Elaine&#39;, &#39;George&#39;, &#39;Newman&#39;] names_uppercase = [] # Use a for loop to convert all the letters in each name to uppercase. for name in names: names_uppercase.append(name.upper()) # Use a map function to convert each letter to uppercase. names_map = map(str.upper, names) # Unpack names_map into a list names_uppercase = [*names_map] . | . The power of NumPy arrays . Overview . NumPy arrays provide a fast and memory efficient alternative to Python lists. | NumPy arrays are homogeneous, which means that the items in an array must be of the same type. It reduces memory consumption. | . Broadcasting . It refers to a NumPy Array’s ability to vectorize operations, so they are efficiently performed over the entire arrays. | exercises . # Create a 2-D array nums = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]]) # Use a for loop to multiply each element by 2 nums_dbl1 = [] for num in nums: nums_dbl1.append(num * 2) # Use a broadcasting to double element efficiently. nums_dbl2 = nums * 2 . | . Boolean indexing . It returns an array object of Boolean type, and this will be useful in filtering desired element values. | exercises . nums = np.array([1, 2, 3, 4, 5]) # Use a for loop to filter elements greater than six. nums_filtered1 = [] for num in nums: if num &gt; 2: nums_filtered.append(num) # Use a boolean indexing to filter elements greater than six efficiently. nums_filtered2 = nums[nums &gt; 2] . | . .",
            "url": "https://mangodm.github.io/tinychanges/python/datacamp/data-engineering/en/2022/07/31/writing-efficient-python-code.html",
            "relUrl": "/python/datacamp/data-engineering/en/2022/07/31/writing-efficient-python-code.html",
            "date": " • Jul 31, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "(KR)12-함수형 반복",
            "content": "에릭 노먼드의 쏙쏙 들어오는 함수형 코딩 12장을 읽고, 정리한 페이지입니다. . . 12. 함수형 반복 . 함수형 프로그래밍 언어에는 컬렉션 데이터를 다루는 강력한 추상 함수들이 존재함. | map(), filter(), reduce()가 대표적인 함수로, 배열을 반복해서 처리하는데 탁월하여 자주 사용됨. | . map() . 함수를 활용하여 X 값이 있는 배열을 Y 값이 있는 배열로 변환함. . . | 리턴값인 결과 배열에 들어 있는 항목은 확인하지 않기 때문에 NULL이나 undefined가 포함될 수 있으니 사용 시 주의가 필요함. | 구현 코드 function map(array, f) { var new_array = []; // 빈 배열 생성 forEach(array, function(element) { new_array.push(f(element)); // 원래 배열 항목에 f 함수를 적용하여 새로운 배열에 추가 }); return new_array; // 새로운 배열을 리턴 } . | . filter() . 함수를 활용하여 X 값이 있는 배열 중, 특정 조건을 만족하는 X 값들만 남긴 배열을 반환함. . . | 조건을 판단하는데 활용되는 함수를 보통 술어(predicate)라고 부름. | 구현 코드 function filter(array, f) { var new_array = []; // 빈 배열 생성 forEach(array, function(element) { if(f(element)) // 원래 배열 항목에 조건을 판단하는 f 함수를 적용 new_array.push(element); // 조건에 해당되는 항목만 결과 배열에 추가 }); return new_array; // 결과 배열을 리턴 } . | . reduce() . 함수를 활용하여 X 값이 있는 배열의 항목에 누적적으로 어떤 동작을 취한 뒤, 최종 결과값을 반환함. . . | 초깃값을 잘못 설정하면 누적의 결과가 의도하지 않게 바뀔 수 있으므로 맥락을 고려하여 신중하게 설정해야 함. (참고) 초깃값을 결정하는 방법 계산이 어떤 값에서 시작되는지(e.g. 더하기(+): 초깃값 0, 곱하기(*): 초깃값 1) | 빈 배열을 사용한다면 어떤 값을 리턴할 것인지(e.g. 빈 문자열을 합친다: 빈 문자열 반환) | 비즈니스 규칙은 무엇인지 | . | . | 특정 시점의 상태 값을 보관할 수 있기 때문에 실행 취소/복귀, 디버깅 등 다양한 곳에 활용될 수 있음. | 구현 코드 function reduce(array, init, f) { // 배열, 초깃값, 누적적인 동작을 정의한 함수 var accum = init; forEach(array, function(element) { accum = f(accum, element); // 누적 값을 계산하기 위해 현재 값과 배열의 항목을 인자로 전달 }); return accum; // 누적된 값을 리턴 } . | .",
            "url": "https://mangodm.github.io/tinychanges/cs/fp/kr/2022/07/28/functional-iteration.html",
            "relUrl": "/cs/fp/kr/2022/07/28/functional-iteration.html",
            "date": " • Jul 28, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "(KR)03-액션과 계산, 데이터의 차이를 알기",
            "content": "에릭 노먼드의 쏙쏙 들어오는 함수형 코딩 3장을 읽고, 정리한 페이지입니다. . . 03. 액션과 계산, 데이터의 차이를 알기 . 개발 과정 전반(설계 &gt; 코딩 &gt; 코드 리뷰)에 걸쳐 액션, 계산, 데이터를 구분하는 기술을 적용할 수 있음. | . 설계 시 Tips . 하나의 액션처럼 보이는 것들을 액션, 계산, 데이터로 세분화하는 연습이 필요함. | 계산 단계는 머릿속에서 자동으로 이뤄지기 때문에 찾기 어려운데 아래 두 질문을 의식적으로 생각하면 찾는 데 도움이 됨. 어떤 단계에서 무엇인가 “결정”해야 할 것이 있나? | 무엇인가 “계획”해서 방법을 찾아야 할 것이 있나? | . | . 코딩 시 Tips . 제약이 많은 것부터 먼저 구현하는 것이 편리함. (i.e. 데이터 &gt; 계산 &gt; 함수) | . 코드 리뷰 시 Tips . 액션이 포함된 함수 역시 액션. 잘못 구성하면 코드 전체가 액션으로 바뀔 수 있음. | 액션은 코드에서 다양한 형태로 나타남. 함수 호출 | 메서드 호출 | 생성자 | 표현식(변수/속성/배열 참조) | 상태(값 할당, 속성 삭제) | . | . 데이터, 계산, 액션 더 자세히 알아보기 . 데이터 . (구현) 기본 데이터 타입(built-in data types)으로 구현하며, 특정 언어에서는 더 정교한 방법으로 생성 가능함. | (의미) 데이터 구조는 의미를 담을 수 있는 수단. (e.g. 목록의 순서가 중요하다면, 순서 보장 가능한 데이터 구조 사용) | (장단점) 직렬화 등의 방법을 사용하면 전송이 편리하고, 서로 비교가 가능하며, 자유롭게 해석할 수 있다는 장점이 있음. 다만, 해석이 없다면 쓸모가 없음. | . 계산 . (구현) 함수 형태로 구현 | (의미) 입력값을 출력값으로 만드는 연산을 담을 수 있음. | (장단점) 테스트와 기계적인 분석이 쉬우며, 조합하기 좋지만, 액션과 마찬가지로 실행하기 전에는 실제 어떤 일이 발생할지 알기 어려움. | . 액션 . (구현) 함수 형태로 구현 | (의미) 외부에 영향을 줄 수 있으므로(i.e. 부수 효과가 있으므로) 어떤 일을 하는지 아는 것이 중요함. | (장단점) 다루기 어렵지만, 소프트웨어를 실행하는 가장 중요한 이유 | 액션을 잘 다루는 Tips 가능한 액션을 적게 사용하기: 액션 &gt; 계산, 데이터 | 가능한 액션을 작게 만들기: 액션에서 액션과 관련 없는 코드는 모두 제거 | 함수형 프로그래밍이 제시하는 기술들로 외부 세계와의 상호작용과 호출 시점에 의존하는 것을 제한 | . | .",
            "url": "https://mangodm.github.io/tinychanges/cs/fp/kr/2022/07/19/distinguishing-acd.html",
            "relUrl": "/cs/fp/kr/2022/07/19/distinguishing-acd.html",
            "date": " • Jul 19, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "(KR)02-현실에서의 함수형 사고",
            "content": "에릭 노먼드의 쏙쏙 들어오는 함수형 코딩 2장을 읽고, 정리한 페이지입니다. . . 02. 현실에서의 함수형 사고 . 변경 가능성에 따라 코드 나누기 . 계층화 설계 맛보기 . 계층화 설계(stratified design): 변경 가능성에 따라 계층을 두어 코드를 구분하는 것 계층 구조로 소프트웨어를 만들면 테스트, 재사용, 유지보수가 쉽다는 장점이 있음. | 일반적으로 비즈니스 규칙, 도메인 규칙, 기술 스택 계층으로 나눔. | . . | . 분산 시스템을 타임라인으로 시각화하기 . 타임라인 다이어그램을 활용하면, 시간에 따라 진행되는 작업을 쉽게 모델링 할 수 있음. | 액션을 수행하는 주체가 하나라면 간단하지만, 여럿으로 바뀌면(i.e. 분산 시스템) 각자의 타임라인이 생기기 때문에 이를 조정하는 시스템이 필요함. . ⇒ 타임라인을 서로 맞추지 않은 시스템은 예측 불가능한 순서로 실행 . ⇒ 타임라인 커팅을 활용하면 여러 타임라인이 동시에 진행될 때 서로 순서를 맞출 수 있음. . . | .",
            "url": "https://mangodm.github.io/tinychanges/cs/fp/2022/07/17/functional-thinking-in-action.html",
            "relUrl": "/cs/fp/2022/07/17/functional-thinking-in-action.html",
            "date": " • Jul 17, 2022"
        }
        
    
  
    
        ,"post4": {
            "title": "(KR)01-함수형 코딩에 오신 것을 환영합니다.",
            "content": "에릭 노먼드의 쏙쏙 들어오는 함수형 코딩 1장을 읽고, 정리한 페이지입니다. . . 함수형 프로그래밍은 무엇인가? . 함수형 프로그래밍의 정의 . 수학 함수를 사용하고 부수 효과를 피하는 것이 특징인 프로그래밍 패러다임 부수 효과(side effect): 함수가 결괏값을 반환하는 것 외에 하는 모든 행동 | . | 부수 효과 없이 순수 함수만 사용하는 프로그래밍 스타일 순수 함수(pure function): 인자에만 의존하고, 부수 효과가 없는 함수 | . | 부수 효과가 있는 (순수하지 않은) 함수는 꼭 필요하지만, 원하지 않는 결과를 만들 수도 있기 때문에 사용 시 주의가 필요함. | . 액션 vs. 계산 vs. 데이터 . 함수형 프로그래밍에서는 코드를 액션, 계산, 데이터 세 가지로 구분함. | 각각의 장단점이 다르기 때문에 이를 잘 알고, 적절하게 쓰는 것이 중요함. | 일반적으로 데이터 &gt; 계산 &gt; 액션 순으로 사용하기 쉬움. | . 구분 특징 예시 . 액션(actions) | 실행 시점이나 횟수에 의존하기 때문에 신중하게 사용해야 함. | sendEmail(to, from, subject, body): 이메일 전송 saveUserDB(user) : 사용자 정보를 데이터 베이스에 저장 getCurrentTime() : 현재 시간 반환 | . 계산(calculations) | 입력값을 계산해 출력하는 것 언제 호출해도 항상 같은 값을 반환함. | sum(numbers): 입력 받은 숫자를 모두 더한 결과 반환 string_length(str): 입력 받은 문자열의 길이 반환 | . 데이터(data) | 이벤트에 대한 사실을 기록한 것 | {&quot;firstname&quot;: &quot;Eric&quot;, &quot;lastname&quot;: &quot;Normand&quot;}: 사람에 대한 정보 [1, 10, 2, 45, 3, 98]: 숫자 리스트 | . 액션 vs. 계산 vs. 데이터로 구분하는 것의 장점 . 함수형 프로그래밍은 분산 시스템에 잘 어울림. 여러 컴퓨터가 네트워크를 통해 통신하는 분산 시스템의 경우, 소프트웨어가 복잡해짐. (e.g. 처리해야 할 메시지 순서 변경, 중복, 유실) | 실행 시점이나 횟수에 의존하는 코드를 없애면(i.e. 액션 &gt; 계산, 데이터) 분산 시스템에서 생기는 여러 문제를 해결할 수 있음. | 불가피하게 액션을 사용하는 경우, 함수형 프로그래밍이 제시하는 액션을 다루는 기술을 활용하면 도움이 됨. | . | .",
            "url": "https://mangodm.github.io/tinychanges/cs/fp/2022/07/15/welcome-to-grokking-simplicity.html",
            "relUrl": "/cs/fp/2022/07/15/welcome-to-grokking-simplicity.html",
            "date": " • Jul 15, 2022"
        }
        
    
  
    
        ,"post5": {
            "title": "(EN) How to Solve Problems",
            "content": "These are notes taken from the Udacity&#39;s Data Structures and Algorithms Nanodegree program. . How to Solve Problems . Solving a problem is one of the most important skills in life, since nearly everything you do can be viewed as solving a problem. Therefore, improving as a problem solver is a lifelong challenge. In this course, we&#39;re going to look at a specific practice problem and talk about how to solve it. The goal of this is not just to solve that particular problem, but to draw some general lessons about how to get better as problem solvers in general. . Days Between Dates . The particular problem that we&#39;ll be working on is called, &quot;Days Between Dates&quot;, and it is: . Given your birthday and the current date, calculate your age in days. Compensate for leap days. Assume that the birthday and current date are correct dates (and no time travel). Simply put, if you were born on the 1 Jan, 2012, and today&#39;s date is 2 Jan, 2012. Then, you&#39;re 1 day old. . Step #1:Understanding the problem . The hardest thing about solving a problem is how to get started. . (Quiz) What might be the first thing to do when we meet the problem at the very first place? . Start writing code It&#39;s often tempting to do it too early, but the problem with it before knowing what needs to be done is we might write the wrong code. | . | Make sure we understand the problem It&#39;s the best option in general, and we&#39;ll cover what does it mean by &quot;understand the problem&quot; later. | . | Search Google for the answer It can be a very good option if this weren&#39;t the practice problem. There can be good solutions out there already! | . | Work out an algorithm that solves it Until we understand the problem well, we don&#39;t know what algorithm we should take. | . | What does it mean, &quot;to understand a (computational) problem&quot;? All computational problems have in common is that they have inputs and (desired) outputs. A solution to a problem is a procedure that can take any input in the possible sets and produce a desired output that satisfies the relationship we want. . Step #2: Understanding the inputs . The very first rule you need to keep in mind when solving a problem is, &quot;Don&#39;t Panic! And keep calm!&quot; This is because if you panic, you will not be able to solve the problem. After then, the next thing you should do is to check what the inputs are. . Let&#39;s figure out what are the inputs of the practice problem: . The inputs are two dates(your birthday and the current date). | What is the set of valid inputs? The second date should be after the first one. | The dates should be valid in the Gregorian calendar, which started in October 1582. | . | How are inputs represented? Six different values will be given to represent those two dates. (e.g. year1, month1, day1, year2, month2, day2) | . | . Step #3: Understanding the outputs . The desired output of the practice problem is the number of days between the first date and the second date. . Step #4: Understanding the relationship (w/ some examples) . You can start coding if you&#39;re confident, but you&#39;d better work out some examples to understand the relationship between inputs and outputs. . (Quiz) For each, give the expected output or undefined if there is no defined output. . days_between_dates(2012, 12, 7, 2012, 12, 7): 0 | days_between_dates(2012, 12, 7, 2012, 12, 8): 1 | days_between_dates(2012, 12, 8, 2012, 12, 7): undefined, since the second date is before the first date | days_between_dates(2012, 6, 29, 2013, 6, 29): 365 | days_between_dates(2012, 6, 29, 2013, 6, 31): undefined, since there is no June 31st in Gregorian calendar. | . Step #5: Consider systematically how a human solves the problem . (Quiz) Find the days between 24 Jan, 2013 and 29 June, 2013. . To solve the problem as a human, we might look at a calendar and count the days. . See how many days do we have left in Jan. (7 days) | Get the number of days in Feb, Mar, Apr, and May and add them up. (28, 31, 30, 31 days each) | Get the number of days until 29 June. (29 days) | Sum all those up! (156 days) | . Step #6: Develop a simple mechanical solution first . The very first approach suggested is to keep it simple as possible. How about starting on the day of first date, and just counting the days until we get the target date? If you&#39;re asked to do the job, you wouldn&#39;t want to do it. But a computer is quite good at doing the brain-dead approach. Once it turns out to be correct, you can come up with some better and efficient solutions later. . Simple mechanical alrogithm . days = 0 while date1 is before date2: date1 = advance to next day days += 1 return days . (Quiz) What should we write first when implementing a simple mechanical algorithm? . days_between_dates: to solve whole problem Too early! | . | next_day(year, month, day): to get the next day for simple case This is sort of the most important thing to make the solution work. | . | is_leap_year(year): to determine if year is leap year Okay to do it, but since it&#39;s a painful to start at the first place, it&#39;s better to leave that until later. | . | days_in_month(month): to get the number of days in a month Too early! | . | . from typing import Tuple def next_day(year: int, month: int, day: int) -&gt; Tuple[int, int, int]: &quot;&quot;&quot; Returns year, month, and day of the next day. This is a simple version, which assumes every month has 30 days. &quot;&quot;&quot; if day &lt; 30: return (year + 1, 1, 1) else: if month == 12: return (year + 1, 1, 1) else: return (year, month + 1, 1) . (Quiz) What should we do next? . refine next_day to work correctly for real months | define days_between_dates to give approximate answers using our next_day procedure Doing this first will give us a lot of confidence we&#39;re on the right track if this works. | . | . def days_between_dates(year1: int, month1: int, day1: int, year2: int, month2: int, day2: int) -&gt; int: &quot;&quot;&quot; Returns the number of days between year1/month1/day1 and year2/month2/day2. Assumes that inputs are valid dates in Gregorian calendar. And the first date is not after the second. &quot;&quot;&quot; .",
            "url": "https://mangodm.github.io/tinychanges/dsa/python/udacity/2022/06/05/how-to-solve-problems.html",
            "relUrl": "/dsa/python/udacity/2022/06/05/how-to-solve-problems.html",
            "date": " • Jun 5, 2022"
        }
        
    
  
    
        ,"post6": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://mangodm.github.io/tinychanges/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post7": {
            "title": "An Example Markdown Post",
            "content": "그들의 장비와 기구는 모두 살아 있다. . 그들의 장비와 기구는 모두 살아 있다. . 그들의 장비와 기구는 모두 살아 있다. . 저 멀리 있는 별을 바라보는 일은 신성한 음악이나 고귀한 그림 또는 위대한 시인의 글귀와 같이 우리의 생각을 자극하고 정화하는 힘을 갖고 있어. 언제나 효과가 좋지. . Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://mangodm.github.io/tinychanges/test/2020/01/14/test-markdown-post.html",
            "relUrl": "/test/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "배운 것들을 기록하는 공간입니다. .",
          "url": "https://mangodm.github.io/tinychanges/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://mangodm.github.io/tinychanges/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}